:toc: left
:toclevels: 5
:sectnums:
:stem:
:source-highlighter: coderay

= 問い合わせモデルの作成

このチュートリアルステップでは、問い合わせモデルを実装します。このコンポーネントの主な目的は、システムに関する情報要求を受け取り、処理することです。これらの要求は、システムに何らかの情報を返すことのみを期待し、その処理がシステムに変更を加えることを意味しないものです。これらは *クエリ（Queries）* と呼ばれます。

クエリ要求を効率的に処理するために、システムはユーザーが情報を要求する形式に一致したデータのバージョン（またはビュー）を保持し、それを更新するように設計されます。期待されるクエリ応答の構造に一致したデータのコピーを保持するこのコンポーネントは、*プロジェクション（Projection）* と呼ばれます。

プロジェクションを最新の状態に保つために、**クエリモデルコンポーネントは、コマンドモデルによって行われた変更を通知するイベントメッセージを受信し、そのプロジェクションを適切に変更する必要があります。** これにより、クエリモデルは最新の情報ビューを返すためにクエリ要求を処理する準備が整います。

システム全体の図を思い出してください。今度は図の下半分に焦点を当て、クエリを処理し応答するために必要なコンポーネントを実装します。

image::images/logic-diagram.png[Design diagram with the logical modules for rental application: An UI/API module contains the HTTP Controller that receives the HTTP POST request to register a new bike. The HTTP Controller sends a RegisterBikeCommand to the Command Model module, including a CommandHandler to maintain the Bike aggregates. After processing a RegisterBikeCommand, the CommandHandler sends a BikeRegisteredEvent to the Query Model module, which keeps a Projection with the data stored on a DB. The Projection on the QueryModel also receives and handles a GetBikesQuery that can be sent from another Controller in the UI/API module.]

== `BikeStatus` レスポンスメッセージの作成

プロジェクションコンポーネントがシステムからの情報要求を処理することに焦点を当てるとした場合、クエリモデルを設計する際に最初に考慮すべきは、処理する具体的な要求と情報を返す方法です。

この場合、アプリケーション内で1台以上のバイクに関する情報（バイクの位置、利用可能かレンタルされているか、誰がレンタルしているか）を返すサポートを実装します。

したがって、これらのクエリから期待されるすべての情報を `BikeStatus` クラスにモデル化します。このクラスを `core-api` に定義します：

[source,java]
.core-api/src/main/java/io/axoniq/demo/bikerental/coreapi/rental/BikeStatus.java
----
package io.axoniq.demo.bikerental.coreapi.rental;

public class BikeStatus {
    private String bikeId;
    private String bikeType;
    private String location;
    private String renter;
    private RentalStatus status;

    public BikeStatus() {
    }
}
----

このクラスは、クエリ応答メッセージに表示する必要のある情報フィールドを定義します。

バイクの状態をモデル化するために、次のJava ENUMを定義します：

[source,java]
.core-api/src/main/java/io/axoniq/demo/bikerental/coreapi/rental/RentalStatus.java
----
package io.axoniq.demo.bikerental.coreapi.rental;

public enum RentalStatus {
    AVAILABLE,
    REQUESTED,
    RENTED
}
----

最後に、`BikeStatus` 応答メッセージのすべてのフィールドを取得するためのメソッドを追加します。つまり、アクセサーメソッドを追加します：

[source,java]
.core-api/src/main/java/io/axoniq/demo/bikerental/coreapi/rental/BikeStatus.java
----
package io.axoniq.demo.bikerental.coreapi.rental;

public class BikeStatus {
    private String bikeId;
    private String bikeType;
    private String location;
    private String renter;
    private RentalStatus status;

    public BikeStatus() {
    }

    // Accessor methods
    public String getBikeId() {
        return bikeId;
    }

    public String getBikeType() {
        return bikeType;
    }

    public String getLocation() {
        return location;
    }

    public String getRenter() {
        return renter;
    }

    public RentalStatus getStatus() {
        return status;
    }

    public String description() {
        switch (status) {
            case RENTED:
                return String.format("Bike %s was rented by %s in %s", bikeId, renter, location);
            case AVAILABLE:
                return String.format("Bike %s is available for rental in %s.", bikeId, location);
            case REQUESTED:
                return String.format("Bike %s is requested by %s in %s", bikeId, renter, location);
            default:
                return "Status unknown";
        }
    }
}
----

== `BikeStatus` プロジェクションの作成

バイクの状態を確認する要求に応じて公開する情報がモデル化されたので、この情報を最新の状態に保ち、クエリ要求が処理されたときに返す準備ができるコンポーネントを作成します。

=== `BikeStatus` クラスとSpring `JpaRepository` の作成

`rental` モジュールの `...rental.query` パッケージに `BikeStatusProjection` クラスを作成する必要があります：

[source,java]
.rental/src/main/java/io/axoniq/demo/bikerental/rental/query/BikeStatusProjection.java
----
package io.axoniq.demo.bikerental.rental.query;

import org.springframework.stereotype.Component;

@Component
public class BikeStatusProjection {

    private final BikeStatusRepository bikeStatusRepository;<.>

    public BikeStatusProjection(BikeStatusRepository bikeStatusRepository) {
        this.bikeStatusRepository = bikeStatusRepository;
    }
}
----
<.> `BikeStatus`モデルを永続化するためにSpringリポジトリを使用し、コマンドモデルからのイベントに基づいて最新の状態に更新します。
プロジェクションで使用するSpring JPAリポジトリを定義する必要があります：

[source,java]
----
package io.axoniq.demo.bikerental.rental.query;

import io.axoniq.demo.bikerental.coreapi.rental.BikeStatus;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.stereotype.Repository;

@Repository<.>
public interface BikeStatusRepository
        extends JpaRepository<BikeStatus, String> {<.>


}
----
<.> `org.springframework.stereotype.Repository` アノテーションは、Springにこのインターフェースから `Repository` コンポーネントを生成するよう指示します。
<.> Spring JPAリポジトリの規約は、`JpaRepository<T, ID>` を拡張するインターフェースを作成することです。ここで、`T` は永続化されるクラスの型で、`ID` は `T` の識別子フィールドの型です。この場合、`T` は `@Entity` で注釈され、`ID` は `T` のフィールドが `@Id` で注釈された型と同じである必要があります。

[NOTE]
====
Spring Dataのサポートにより、基本的な操作（ `BikeStatus` インスタンスのデータベース内で保存、更新、変更、クエリ、および削除）をサポートするためにこれだけを定義する必要があります。
Spring Data JPAリファレンスの"Defining Repository Interfaces"に関するセクションでSpring Data Repositoriesについてさらに学ぶことができます。 詳細は https://docs.spring.io/spring-data/jpa/reference/repositories/definition.html を参照してください。
====

最後に、リポジトリを動作させるために、`core-api` モジュールの `BikeStatus` クラスを開き、永続化アノテーションを追加します：

[source,java]
.core-api/src/main/java/io/axoniq/demo/bikerental/coreapi/rental/BikeStatus.java
----
package io.axoniq.demo.bikerental.coreapi.rental;

import jakarta.persistence.Entity;
import jakarta.persistence.Id;

@Entity<.>
public class BikeStatus {

    @Id<.>
    private String bikeId;
    private String bikeType;
    private String location;
    private String renter;
    private RentalStatus status;

    public BikeStatus() {
    }

    public BikeStatus(String bikeId, String bikeType, String location) {
        this.bikeId = bikeId;
        this.bikeType = bikeType;
        this.location = location;
        this.status = RentalStatus.AVAILABLE;
    }
    // Accessor methods
    public String getBikeId() {
        return bikeId;
    }

    public String getBikeType() {
        return bikeType;
    }

    public String getLocation() {
        return location;
    }

    public String getRenter() {
        return renter;
    }

    public RentalStatus getStatus() {
        return status;
    }

    public String description() {
        switch (status) {
            case RENTED:
                return String.format("Bike %s was rented by %s in %s", bikeId, renter, location);
            case AVAILABLE:
                return String.format("Bike %s is available for rental in %s.", bikeId, location);
            case REQUESTED:
                return String.format("Bike %s is requested by %s in %s", bikeId, renter, location);
            default:
                return "Status unknown";
        }
    }
}
----
<.> `Entity` アノテーションは、このクラスを永続エンティティとしてマークします。Springの `JpaRepository<T,ID>` の `T` です。
<.> このアノテーションは、永続化層に `bikeId` を永続レコードの識別子として考慮させるよう指示します。`@Id` で注釈されたフィールドの型（この場合は `String` ）は、Springの `JpaRepository<T,ID>` の `ID` です。

これらの変更によって、コマンドモデルが行った変更を通知するイベントを処理し、`BikeStatus` を更新して永続化する方法を定義する準備が整いました。

=== `BikeRegisteredEvent` ハンドラの定義

クエリモデル内のバイクリストを最新の状態に保つために、システム内で新しいバイクが登録されたときに呼び出されるメソッドを定義する必要があります（ `BikeRegisteredEvent` はその通知を表します）。`BikeStatusProjection` に `@EventHandler` メソッドを追加してこれを行うことができます：
[source,java]
.rental/src/main/java/io/axoniq/demo/bikerental/rental/query/BikeStatusProjection.java
----
package io.axoniq.demo.bikerental.rental.query;

import io.axoniq.demo.bikerental.coreapi.rental.BikeRegisteredEvent;
import io.axoniq.demo.bikerental.coreapi.rental.BikeStatus;
import org.axonframework.eventhandling.EventHandler;
import org.springframework.stereotype.Component;

@Component
public class BikeStatusProjection {

    private final BikeStatusRepository bikeStatusRepository;

    public BikeStatusProjection(BikeStatusRepository bikeStatusRepository) {
        this.bikeStatusRepository = bikeStatusRepository;
    }

    @EventHandler<.>
    public void on(BikeRegisteredEvent event) {<.>
        var bikeStatus = new BikeStatus(event.bikeId(), event.bikeType(), event.location());<.>
        bikeStatusRepository.save(bikeStatus);<.>
    }


}
----
<.> `@EventHandler` アノテーションは、Axon Frameworkにこのコンポーネントを `BikeRegisteredEvent` のサブスクライバーとして登録し、各イベントごとにこのメソッドを呼び出すよう指示します。
<.> Axon Frameworkはデフォルトで、メソッド定義の最初の引数を使用して受信するイベントのタイプを一致させ、イベントをメソッドの引数として渡します。
<.> `BikeRegisteredEvent` はシステム内に新しいバイクが作成されたことを意味するため、生成する新しいバイクの状態を表す `BikeStatus` の新しいインスタンスを作成する必要があります。
<.> 最後に、`BikeStatus` を `bikeStatusRepository` を介して永続化します。

== プロジェクションからのクエリの処理

プロジェクションの次のタスクは、クエリを処理し、現在の情報を返すサポートを実装することです。

サポートするクエリごとに `@QueryHandler` メソッドを追加する必要があります。すでに必要な情報を返す方法でバイクのステータスが永続化されているので、データベースをクエリしてそれを返すだけです。

クエリを処理するメソッドを作成する前に、異なるクエリを識別する方法を考慮する必要があります。

=== 名前付きクエリの使用

Axon Frameworkは、クエリメッセージを識別し、そのクエリを正しいメソッドにリンクするためのさまざまな方法を提供しています。このチュートリアルでは、クエリを識別する最も簡単な方法を使用します：クエリごとに名前を付けます。

クエリ名を参照するモジュールとそれを処理するコンポーネントの両方で常に同じクエリ名を参照するようにするために、`String` 定数を使用します。

なので、まずはこれらのクエリ名を定義し、異なるコンポーネント間で共有するクラスを作成します。`core-api` モジュールに以下のクラスを定義します。

[source,java]
./core-api/src/main/java/io/axoniq/demo/bikerental/coreapi/rental/BikeStatusNamedQueries.java
----
package io.axoniq.demo.bikerental.coreapi.rental;

public class BikeStatusNamedQueries {
    public static final String FIND_ALL = "findAll";
    public static final String FIND_ONE = "findOne";
    public static final String FIND_AVAILABLE = "findAvailable";
}
----

これでクエリ名が定義されたので、次はそれらを処理し応答するメソッドを定義します。


=== すべての自転車を返すクエリの実装

システム内に定義されたすべての自転車（その状態も含む）を返すメソッドの実装から始めましょう。以下のメソッドを `BikeStatusProjection` クラスに追加します：

[source,java]
.rental/src/main/java/io/axoniq/demo/bikerental/rental/query/BikeStatusProjection.java
----
package io.axoniq.demo.bikerental.rental.query;

import io.axoniq.demo.bikerental.coreapi.rental.BikeRegisteredEvent;
import io.axoniq.demo.bikerental.coreapi.rental.BikeStatus;
import io.axoniq.demo.bikerental.coreapi.rental.BikeStatusNamedQueries;
import org.axonframework.eventhandling.EventHandler;
import org.axonframework.queryhandling.QueryHandler;
import org.springframework.stereotype.Component;

@Component
public class BikeStatusProjection {

    private final BikeStatusRepository bikeStatusRepository;

    public BikeStatusProjection(BikeStatusRepository bikeStatusRepository) {
        this.bikeStatusRepository = bikeStatusRepository;
    }

    @EventHandler
    public void on(BikeRegisteredEvent event) {
        var bikeStatus = new BikeStatus(event.bikeId(), event.bikeType(), event.location());
        bikeStatusRepository.save(bikeStatus);
    }

    @QueryHandler(queryName = BikeStatusNamedQueries.FIND_ALL)<.>
    public Iterable<BikeStatus> findAll() {<.>
        return bikeStatusRepository.findAll();<.>
    }

}
----
<.> `org.axonframework.queryhandling.QueryHandler` アノテーションは、Axon Frameworkにこのメソッドを特定のタイプのクエリのターゲットとして登録するよう指示します。この場合、クエリ名で識別し、このメソッドで処理する特定のクエリ名を `queryName` 属性で指定します。
<.> クエリにはパラメータがないので（システム内の *すべての自転車* の情報を取得したい場合）、クエリハンドラーメソッドはパラメータを受け取りません。DBから見つかったアイテムのリストを返すだけで済みます。
<.> 情報はすでに準備されており（ `EventHandler` のおかげで）レスポンス形式に整っているので、リポジトリから情報を取得して返すだけで済みます。

要するに、Axon Frameworkがシステム内の `findAll` バイクのクエリメッセージを受信すると、このクエリハンドラーメソッドが呼び出されます。このメソッドはDBから最新の情報を取得し、すべてのバイクの `BikeStatus` を返すだけです。


=== 他のクエリに対応するプロジェクションの実装

システム内のバイクに関する異なるクエリリクエストをサポートする必要があります。同じプロジェクションを使用して異なるクエリを満たすことができます。

たとえば、特定のタイプでフィルタリングされたすべての利用可能なバイクを返すクエリや、`bikeId` によって特定のバイクの `BikeStatus` を返すクエリをサポートしたい場合、以下の2つのメソッドを `BikeStatusProjection` に追加できます：

[source,java]
.rental/src/main/java/io/axoniq/demo/bikerental/rental/query/BikeStatusProjection.java
----
package io.axoniq.demo.bikerental.rental.query;

import io.axoniq.demo.bikerental.coreapi.rental.BikeRegisteredEvent;
import io.axoniq.demo.bikerental.coreapi.rental.BikeStatus;
import io.axoniq.demo.bikerental.coreapi.rental.BikeStatusNamedQueries;
import io.axoniq.demo.bikerental.coreapi.rental.RentalStatus;
import org.axonframework.eventhandling.EventHandler;
import org.axonframework.queryhandling.QueryHandler;
import org.springframework.stereotype.Component;

@Component
public class BikeStatusProjection {

    private final BikeStatusRepository bikeStatusRepository;

    public BikeStatusProjection(BikeStatusRepository bikeStatusRepository) {
        this.bikeStatusRepository = bikeStatusRepository;
    }

    @EventHandler
    public void on(BikeRegisteredEvent event) {
        var bikeStatus = new BikeStatus(event.bikeId(), event.bikeType(), event.location());
        bikeStatusRepository.save(bikeStatus);
    }

    @QueryHandler(queryName = BikeStatusNamedQueries.FIND_ALL)
    public Iterable<BikeStatus> findAll() {
        return bikeStatusRepository.findAll();
    }

    @QueryHandler(queryName = BikeStatusNamedQueries.FIND_AVAILABLE)<.>
    public Iterable<BikeStatus> findAvailable(String bikeType) {<.>
        return bikeStatusRepository.findAllByBikeTypeAndStatus(bikeType, RentalStatus.AVAILABLE);
    }

    @QueryHandler(queryName = BikeStatusNamedQueries.FIND_ONE)<.>
    public BikeStatus findOne(String bikeId) {<.>
        return bikeStatusRepository.findById(bikeId).orElse(null);<.>
    }

}
----
<.> `findAvailable` クエリ用の新しい `QueryHandler` メソッドを定義します。
<.> クエリはバイクのタイプでフィルタリングするので、メソッドに `bikeType` 引数を追加する必要があります。
<.> DBへのクエリを実装するために、`BikeStatusRepository` に特定のメソッドを追加する必要があります。Spring Dataを使用しているため、このメソッドの名前は特定のパターンに従う必要があります。（この後、もう少し詳しく説明します）
<.> `FIND_ONE` クエリ用の別の `QueryHandler` メソッドを定義します。
<.> このクエリでは一つのバイクのみを返し、そのためには `bikeId` をメソッドの引数として追加する必要があります。単一の要素を返すので、このメソッドは単一の `BikeStatus` を返します。
<.> Spring Dataの `JpaRepository` が提供するデフォルトの `findById` メソッドは、`id` に基づいてアイテムを検索する際、`Optional<T>` を返します。これは、検索している `id` がDBに存在しない可能性があるためです。そのため、DBに指定された `bikeId` のバイクが存在しない場合に `null` を返すフォールバックを追加します。

最後に、Spring Dataの `BikeStatusRepository` にメソッドを追加して、`bikeType` と `status` でDB内のすべてのレコードをフィルタリングする特定メソッドをサポートする必要があります。幸いにもSpring Dataのおかげで、インターフェースに特定の名前付けパターンに従う新しいメソッドを定義するだけで、Spring DataはDBへの対応するSQLクエリを持つ実装を生成します。

`BikeStatusRepository`に次のメソッドを追加します：
[source,java]
----
package io.axoniq.demo.bikerental.rental.query;

import io.axoniq.demo.bikerental.coreapi.rental.BikeStatus;
import io.axoniq.demo.bikerental.coreapi.rental.RentalStatus;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.stereotype.Repository;

import java.util.List;

@Repository
public interface BikeStatusRepository
        extends JpaRepository<BikeStatus, String> {

    List<BikeStatus> findAllByBikeTypeAndStatus(String bikeType, RentalStatus status);
    long countBikeStatusesByBikeType(String bikeType);

}
----

[NOTE]
====
`JpaRepository<T,ID>` を拡張したSpring Data JPAリポジトリを定義すると、Spring Dataはデータベースをクエリする基本的なメソッドセットの実装を生成します。これらの生成されたメソッドは、データベースのレコードを作成、更新、クエリ、削除する操作をカバーします。

異なる基準に応じてエレメントをフィルタリングする追加のクエリを定義する必要がある場合があります。このようなタイプのクエリには、インターフェースに新しいメソッドを定義し、特定の名前付け規則に従うと、Springはメソッドの名前と引数から実行する必要のあるクエリを推論できます。

これは *派生クエリ* と呼ばれることがあり、Spring Dataリファレンスガイドの https://docs.spring.io/spring-data/commons/reference/repositories/query-methods-details.html#repositories.query-methods.query-creation[Query Creation from the Spring Data Reference guide] セクションで、さまざまなクエリ用の特定のメソッドの追加方法を学ぶことができます。
====

これで `BikeStatusProjection` はシステム内のクエリに応答できるようになりました。具体的には、すべてのバイクを `findAll` 、特定のタイプの利用可能なバイクを `findAvailable` 、および `bikeId` を指定して特定のバイクを `findOne` とするクエリに対応できます。

次のセクションでは、これらのクエリのエンドポイントを追加し、クエリをシステムにルーティングする `RestController` を拡張します。

== クエリリクエストを受け付けるエンドポイントの作成

プロジェクションでクエリを処理する完全なサポートがあるため、クエリのHTTPリクエストを受け取り、対応するクエリメッセージを内部でルーティングするコントローラのエンドポイントを実装して公開します。

これを行うために、前のセクションで作成した `RentalController` にいくつかの `@GetMapping` アノテーション付きのメソッドを追加します。これらのメソッドは、すでに追加した `QueryGateway` を使用して、Axon Frameworkを介してクエリをルーティングします：

[source,java]
./rental/src/main/java/io/axoniq/demo/bikerental/rental/ui/RentalController.java
----
package io.axoniq.demo.bikerental.rental.ui;

import io.axoniq.demo.bikerental.coreapi.rental.RegisterBikeCommand;
import org.axonframework.commandhandling.gateway.CommandGateway;
import org.axonframework.queryhandling.QueryGateway;
import org.springframework.web.bind.annotation.PostMapping;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RequestParam;
import org.springframework.web.bind.annotation.RestController;

import java.util.UUID;
import java.util.concurrent.CompletableFuture;

@RestController<.>
@RequestMapping("/")<.>
public class RentalController {

    private final CommandGateway commandGateway;<.>
    private final QueryGateway queryGateway;<.>

    private final BikeRentalDataGenerator bikeRentalDataGenerator;

    public RentalController(CommandGateway commandGateway, QueryGateway queryGateway, BikeRentalDataGenerator bikeRentalDataGenerator) {
        this.commandGateway = commandGateway;
        this.queryGateway = queryGateway;
        this.bikeRentalDataGenerator = bikeRentalDataGenerator;
    }

    @PostMapping("/bikes")
    public CompletableFuture<String> registerBike(
            @RequestParam("bikeType") String bikeType,
            @RequestParam("location") String location) {

        RegisterBikeCommand registerBikeCommand =
                new RegisterBikeCommand(
                        UUID.randomUUID().toString(),
                        bikeType,
                        location);

        CompletableFuture<String> commandResult =
                commandGateway.send(registerBikeCommand);

        return commandResult;
    }
}
----
<.> Springの `RestController` アノテーションは、このコンポーネントをRESTエンドポイントURLを公開するものとして定義します。
<.> `@RequestMapping` アノテーションは、このコントローラーによって公開されるすべてのエンドポイントのルートURLを設定します。
<.> `CommandGateway` はコマンドをルーティングするためにすでに使用したAxon Frameworkのコンポーネントです。
<.> `QueryGateway` は、今回はクエリメッセージをルーティングするために使用するAxon Frameworkのコンポーネントです。

=== `findAll` クエリのエンドポイント実装

すべてのバイクとその状態を返すエンドポイントを公開するメソッドを実装するために、次のメソッドを `RentalController` に追加します：

[source,java]
./rental/src/main/java/io/axoniq/demo/bikerental/rental/ui/RentalController.java
----
package io.axoniq.demo.bikerental.rental.ui;

import io.axoniq.demo.bikerental.coreapi.rental.BikeStatus;
import io.axoniq.demo.bikerental.coreapi.rental.BikeStatusNamedQueries;
import io.axoniq.demo.bikerental.coreapi.rental.RegisterBikeCommand;
import org.axonframework.commandhandling.gateway.CommandGateway;
import org.axonframework.messaging.responsetypes.ResponseTypes;
import org.axonframework.queryhandling.QueryGateway;
import org.springframework.web.bind.annotation.*;

import java.util.List;
import java.util.UUID;
import java.util.concurrent.CompletableFuture;

@RestController
@RequestMapping("/")
public class RentalController {

    private final CommandGateway commandGateway;
    private final QueryGateway queryGateway;

    private final BikeRentalDataGenerator bikeRentalDataGenerator;

    public RentalController(CommandGateway commandGateway, QueryGateway queryGateway, BikeRentalDataGenerator bikeRentalDataGenerator) {
        this.commandGateway = commandGateway;
        this.queryGateway = queryGateway;
        this.bikeRentalDataGenerator = bikeRentalDataGenerator;
    }

    @PostMapping("/bikes")
    public CompletableFuture<String> registerBike(
            @RequestParam("bikeType") String bikeType,
            @RequestParam("location") String location) {

        RegisterBikeCommand registerBikeCommand =
                new RegisterBikeCommand(
                        UUID.randomUUID().toString(),
                        bikeType,
                        location);

        CompletableFuture<String> commandResult =
                commandGateway.send(registerBikeCommand);

        return commandResult;
    }

    @GetMapping("/bikes") //<.>
    public CompletableFuture<List<BikeStatus>> findAll() { //<.>
        return queryGateway.query( //<.>
                BikeStatusNamedQueries.FIND_ALL, //<.>
                null, //<.>
                ResponseTypes.multipleInstancesOf(BikeStatus.class) //<.>
        );
    }
}
----
<.> `GetMapping` Springアノテーションは、このメソッドがアプリケーションに `GET` リクエストを受信したときに呼び出されることを指定します。
<.> メソッドは `BikeStatus` レスポンスのリストを返します。`CompletableFuture` を直接返すか `List<BikeStatus>` を返すかについての説明は情報ブロックを参照してください。
<.> クエリをルーティングするために、AxonFrameworkが提供する `queryGateway` コンポーネントの `query` メソッドを使用します。このメソッドは3つのパラメータを受け取ります。
<.> クエリ。それはオブジェクトまたはクエリ名を含む `String` であることができます。この場合、クエリが単純なものであるため、クエリ名を使用することを選択しています。
<.> クエリ自体であり、結果をフィルタリングするためのパラメータまたは条件を持ちます。この場合、`findAll` クエリにはフィルタがないため、クエリとして `null` を指定します。
<.> このクエリから期待するレスポンスタイプ。この場合、`BikeStatus` のインスタンス1つ以上を期待します。

[NOTE]
====
*RestControllerメソッドからCompletableFutureを返すことに関するパフォーマンス考慮事項*

`queryGateway` は `CompletableFuture<T>` を返します。これはクエリの実行結果への参照を保持し、その結果が準備できたときに `T` タイプの結果を取得できます。

これにより、クエリメソッドの呼び出しはブロックせず、クエリメッセージをクエリバスに送信した後、すぐに戻ることができます。レスポンスメッセージがまだ計算されていなくてもです。

このように、Axon Frameworkを使用すると、クエリメッセージを送信するコードはクエリが完全に実行されるまで待つ必要がなく、レスポンスが受信される間に他のことを行うことができます。`CompletableFuture` の `get()` メソッドを呼び出したときにのみ、実行スレッドはレスポンスの準備ができるまでブロックされます。

結果の代わりにメソッドを実装し、`CompletableFuture::get` メソッドの結果を返すこともできます：

[source,java]
----
public List<BikeStatus> findAll() {
    CompletableFuture<List<BikeStatus>> result =
        queryGateway.query(FIND_ALL_QUERY, null, ResponseTypes.multipleInstanceOf(BikeStatus.class));
    return result.get(); //<.>
}
----
<.> `get()` 呼び出しはレスポンスが戻るまでスレッドをブロックします。

この場合、`findAll` メソッドを呼び出すスレッドはレスポンスメッセージを受信するまでブロックされ、したがって、Tomcatのワーカースレッドがブロックされます。

メソッドから `CompletableFuture<List<BikeStatus>>` を返すことで、`findAll` 内でTomcatワーカースレッドをブロックしません。

====

=== `findOne` クエリのエンドポイント実装

同様に、`bikeId` によって特定のバイクの `BikeStatus` を取得するリクエストを受け付けるエンドポイントを公開するためのもう1つの `@GetMapping` アノテーション付きメソッドを追加できます：

[source,java]
./rental/src/main/java/io/axoniq/demo/bikerental/rental/ui/RentalController.java
----
package io.axoniq.demo.bikerental.rental.ui;

import io.axoniq.demo.bikerental.coreapi.rental.BikeStatus;
import io.axoniq.demo.bikerental.coreapi.rental.BikeStatusNamedQueries;
import io.axoniq.demo.bikerental.coreapi.rental.RegisterBikeCommand;
import org.axonframework.commandhandling.gateway.CommandGateway;
import org.axonframework.messaging.responsetypes.ResponseTypes;
import org.axonframework.queryhandling.QueryGateway;
import org.springframework.web.bind.annotation.*;

import java.util.List;
import java.util.UUID;
import java.util.concurrent.CompletableFuture;

@RestController
@RequestMapping("/")
public class RentalController {

    private final CommandGateway commandGateway;
    private final QueryGateway queryGateway;

    private final BikeRentalDataGenerator bikeRentalDataGenerator;

    public RentalController(CommandGateway commandGateway, QueryGateway queryGateway, BikeRentalDataGenerator bikeRentalDataGenerator) {
        this.commandGateway = commandGateway;
        this.queryGateway = queryGateway;
        this.bikeRentalDataGenerator = bikeRentalDataGenerator;
    }

    @PostMapping("/bikes")
    public CompletableFuture<String> registerBike(
            @RequestParam("bikeType") String bikeType,
            @RequestParam("location") String location) {

        RegisterBikeCommand registerBikeCommand =
                new RegisterBikeCommand(
                        UUID.randomUUID().toString(),
                        bikeType,
                        location);

        CompletableFuture<String> commandResult =
                commandGateway.send(registerBikeCommand);

        return commandResult;
    }

    @GetMapping("/bikes")
    public CompletableFuture<List<BikeStatus>> findAll() {
        return queryGateway.query(
                BikeStatusNamedQueries.FIND_ALL,
                null,
                ResponseTypes.multipleInstancesOf(BikeStatus.class)
        );
    }

    @GetMapping("/bikes/{bikeId}") // <.>
    public CompletableFuture<BikeStatus> findStatus(@PathVariable("bikeId") String bikeId) { //<.>
        return queryGateway.query(BikeStatusNamedQueries.FIND_ONE, bikeId, BikeStatus.class); //<.>
    }
}
----
<.> `@GetMapping` アノテーションは、`/bikes/{bikeId}` への `GET` リクエストを受信したときにメソッドが呼び出されることを設定し、`/bikes/` の後に来るURLの一部を `bikeId` パス変数に割り当てます。
<.> `@PathVariable("bikeId")` アノテーションはSpringにURLの値を提供するよう指示し、それをメソッド引数の `bikeId` パス変数で一致させます。
<.> クエリメッセージを送信するために `queryGateway` の `query` メソッドを使用します。この場合、提供された `bikeId` をクエリの条件として指定し、期待するレスポンスタイプとして `BikeStatus.class` を指定します。

== クエリの実行と呼び出し

これで前述した方法でアプリケーションを再実行し、クエリが機能することをテストできます。

[NOTE]
====

コマンドハンドラを実装した後、新しいバイクを登録するエンドポイントを呼び出したとき、コマンドハンドラは対応する `BikeRegisteredEvent` をトリガーし、変更を通知するイベントを送信します。

そのとき、まだ `BikeStatusProjection` が実装されていなかったため、これらの `BikeRegisteredEvent` に対応するイベントハンドラがありませんでした。これらの変更はどうなったのでしょうか？これらのイベントは失われたのでしょうか？クエリモデルをどうやって最新に保つのでしょうか？

Axon Serverはメッセージブローカーとして動作し（Events、Commands、Queriesをルーティングするように最適化され構成されています）、イベントストアとしても機能します。つまり、これらのイベントがすべて永続化されているだけでなく、イベントソーシングアーキテクチャで必要なストレージと取得パターンに最適化されています。

`docker-compose.yml` ファイルで設定された通りにAxon Serverを起動すると、Axon Serverは起動し、以前のすべてのイベントがまだ利用可能です。アプリケーションが接続し、`BikeRegisteredEvent` のイベントハンドラを登録すると、Axon Serverはこのコンポーネントがすべてのイベントを最初から必要とする新しいコンポーネントであることを認識します。結果として、Axon Serverは `BikeStatusProjection` に過去のすべてのイベントを発生順に配信します。

====

=== `findAll` および `findOne` クエリの呼び出し

`findAll` クエリをテストするには、次のエンドポイントに `HTTP GET` リクエストを送信するだけです：

 http://localhost:8080/bikes

特定のバイクのステータスを取得するには、次のURLに `HTTP GET` リクエストを送信する必要があります：

 http://localhost:8080/bikes/{bikeId}


==== コマンドラインから

エンドポイントをコマンドラインから呼び出すには、 `curl` コマンドを使用します：

[,console]
----
% curl -X GET "http://localhost:8080/bikes"
[
  {
    "bikeId": "8427681b-1ee6-4e0a-b5d8-c524b9ed553d",
    "bikeType": "city",
    "location": "Utrecht",
    "renter": null,
    "status": "AVAILABLE"
  },
  {
    "bikeId": "9f4572c0-c09d-4452-bd31-e0464143baf7",
    "bikeType": "city",
    "location": "Utrecht",
    "renter": null,
    "status": "AVAILABLE"
  },
  {
    "bikeId": "547a47fa-573b-4140-88af-0ea84862944b",
    "bikeType": "city",
    "location": "Utrecht",
    "renter": null,
    "status": "AVAILABLE"
  }
]
----

また、`findOne` クエリを呼び出すこともできます：
[,console]
----
% curl -X GET "http://localhost:8080/bikes/8427681b-1ee6-4e0a-b5d8-c524b9ed553d"
{
  "bikeId": "8427681b-1ee6-4e0a-b5d8-c524b9ed553d",
  "bikeType": "city",
  "location": "Utrecht",
  "renter": null,
  "status": "AVAILABLE"
}
----


==== IntelliJ IDEA を使用する

IntelliJ IDEA を使用している場合、 xref:invoking-create-bike-endpoint.adoc#_using_intellij_idea[Create Bike エンドポイントの呼び出し] で作成した `requests.http` ファイルに以下の行を追加します：

[source,httprequest]
./requests.http
----
### List all
# Show available bikes
GET {{rental}}/bikes
Accept: application/json

### Bike status
# Show bike status
GET {{rental}}/bikes/8427681b-1ee6-4e0a-b5d8-c524b9ed553d
Accept: application/json

###
----

リクエストの右に表示される緑色の "play" アイコンをクリックして、リクエストを実行します：

[source,console]
----
GET http://localhost:8080/bikes

HTTP/1.1 200 OK
Vary: Origin
Vary: Access-Control-Request-Method
Vary: Access-Control-Request-Headers
Content-Type: application/json
Content-Length: 497

[
  {
    "bikeId": "4ee11ca7-3a38-4c37-9584-f016e450998e",
    "bikeType": "city",
    "location": "Utrecht",
    "renter": null,
    "status": "AVAILABLE"
  },
  {
    "bikeId": "9f4572c0-c09d-4452-bd31-e0464143baf7",
    "bikeType": "city",
    "location": "Utrecht",
    "renter": null,
    "status": "AVAILABLE"
  },
  {
    "bikeId": "547a47fa-573b-4140-88af-0ea84862944b",
    "bikeType": "city",
    "location": "Utrecht",
    "renter": null,
    "status": "AVAILABLE"
  },
  {
    "bikeId": "d29775ea-2cd6-4102-b887-552d4cdb84db",
    "bikeType": "city",
    "location": "Utrecht",
    "renter": null,
    "status": "AVAILABLE"
  }
]
Response file saved.
> 2024-04-22T173839.200.json

Response code: 200 (OK); Time: 34ms (34 ms); Content length: 497 bytes (497 B)
----

== 結論

これにより、スケールアウトしやすいアプリケーションでメインメッセージハンドラーコンポーネントの例を実装しました：

- `Bike` アグリゲートの実装を含む*コマンドモデル*があります。これは `@CommandHandler` を定義し、コマンドの処理結果としてシステムで行われた変更を通知するイベントを送信します。*コマンドモデル* はまた、いくつかの `@EventSourcingHandler` を使用してこれらのイベントを購読します。この方法で、コマンドハンドラーによって生成された一連のイベントがシステムの *真の情報源* であることを保証できます。
- また、データの *Projection* で構成される *クエリモデル* を定義しました。これにより、情報リクエストにできるだけ迅速に応答できる構造が維持されます。これらのクエリは、Projectionに定義された `@QueryHandlers` によって処理されます。
- *Projection* のデータを最新に保つために、`@CommandHandler` によって送信されたイベントの受信時に実行される各種 `@EventHandler` を定義しました。これらのイベントハンドラーは対応するDBを更新します。
- 最後に、新しいバイクを登録するリクエストや全バイクまたは個々のバイクの情報を取得するクエリのエンドポイントを公開する `@RestController` を実装しました。これらのコントローラーメソッドは、Axon Framework が提供する `CommandGateway` または `QueryGateway` を介して対応する `Command` または `Query` メッセージを送信します。

これらは、システムのさらなる機能を実装するために使用する基本コンポーネントです。時々、それらの機能は少し複雑になることがあり、ビジネスロジックには追加の考慮事項が必要です。

次のセクションでは、Axon Framework を使用したアプリケーション構築に関するより高度なトピックを探ります。